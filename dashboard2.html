<!doctype html>
<html lang="en">
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XBHVRKLJCD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-XBHVRKLJCD');
</script>
<meta charset="utf-8" />
<title>Interactive Sites Map — Ultimate</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
  :root{
    --bg:#e0eaff;
    --card:#ffffff80;
    --accent:#2F80ED;
    --accent-hover:#1C60B3;
    --shadow:0 8px 30px rgba(0,0,0,0.12);
    --radius:12px;
  }
  html, body { margin:0; height:100%; font-family: 'Inter', system-ui, Arial; background: linear-gradient(to bottom right, #e0eaff, #ffffff); color:#222; font-size:14px; line-height:1.5; }
  .app{ display:grid; grid-template-columns:380px 1fr; gap:16px; height:100vh; padding:16px; box-sizing:border-box; }
  .panel{ background:var(--card); backdrop-filter: blur(12px); border-radius:var(--radius); padding:16px; box-shadow:var(--shadow); display:flex; flex-direction:column; overflow:auto; border:1px solid rgba(255,255,255,0.3); }
  #map{ height:100%; border-radius:var(--radius); box-shadow:var(--shadow); border:2px solid rgba(255,255,255,0.3); position:relative; }
  
  /* Cursors for tools */
  .crosshair-cursor { cursor: crosshair !important; }

  h2{ margin-bottom:12px; font-weight:700; font-size:1.4em; color:#1a1a1a; }
  label{ font-weight:600; color:#333; }
  .controls{ display:flex; flex-direction:column; gap:12px; }
  .row{ display:flex; gap:12px; align-items:center; }
  select,input[type=text]{ padding:8px 10px; border-radius:var(--radius); border:1px solid #ccc; transition:0.2s; width: 100%; }
  .btn{ padding:10px 16px; border-radius:var(--radius); border:none; font-weight:600; cursor:pointer; color:#fff; background: linear-gradient(135deg,var(--accent),#1e5fc1); transition:0.3s; box-shadow:0 4px 12px rgba(0,0,0,0.2); }
  .stat{ background:rgba(255,255,255,0.85); flex:1; padding:12px; border-radius:var(--radius); box-shadow:0 4px 12px rgba(0,0,0,0.08); text-align:center; }
  .stat .small{ font-weight:500; color:#555; margin-bottom:4px; }
  .stat .big-num { font-weight:700; font-size:24px; margin-top:4px; font-variant-numeric: tabular-nums; letter-spacing: -0.5px; color:#111; }
  
  /* Legend Styles */
  .legend .sw { 
    width:16px; 
    height:16px; 
    border-radius:50%; 
    display:inline-block; 
    margin-right:8px; 
    border:2px solid #fff; 
    box-shadow:0 0 4px rgba(0,0,0,0.25); 
    vertical-align:middle; 
    cursor: pointer;
    transition: transform 0.2s;
  }
  .legend .sw:hover { transform: scale(1.2); }

  #details{ font-size:14px; color:#222; margin-top:8px; padding:8px; border-radius:var(--radius); background:rgba(255,255,255,0.7); box-shadow:0 4px 12px rgba(0,0,0,0.08); min-height:64px; }
  
  /* Map Buttons */
  .map-btn {
    position:absolute; right:20px; z-index:999;
    width:44px; height:44px; border-radius:50%;
    background:white; display:flex; align-items:center; justify-content:center;
    cursor:pointer; border:2px solid #444; box-shadow:0 4px 10px rgba(0,0,0,0.3);
    transition: transform 0.2s, background 0.2s;
  }
  .map-btn:hover { transform: scale(1.05); background:#f9f9f9; }
  .map-btn.active { background: var(--accent); border-color:var(--accent); }
  .map-btn.active img { filter: brightness(0) invert(1); } /* Make icon white */
  
  .map-btn img { width:24px; height:24px; }
  
  /* Stacking Order */
  #sniperBtn { bottom:20px; }
  #settingsBtn { bottom:76px; }
  #measureBtn { bottom:132px; }
  #gpsBtn { bottom:188px; }

  /* Settings Menu */
  #settingsMenu {
    position: absolute; bottom: 80px; right: 74px; z-index: 1000;
    background: white; padding: 10px; border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    display: none; flex-direction: column; gap: 6px;
    min-width: 140px; border: 1px solid #ddd;
  }
  #settingsMenu.show { display: flex; }
  .style-option {
    padding: 8px 12px; cursor: pointer; border-radius: 6px; font-weight: 500; color: #333;
    transition: background 0.2s;
  }
  .style-option:hover { background: #f0f4ff; color: var(--accent); }
  .style-option.active { background: var(--accent); color: white; }

  /* Measure Tooltip */
  .measure-tooltip {
    background: rgba(0,0,0,0.8); color: #fff; padding: 4px 8px; border-radius: 4px; font-weight: bold; font-size: 12px; white-space: nowrap; pointer-events: none;
  }

  @media(max-width:950px){ .app{ grid-template-columns:1fr; grid-template-rows:320px 1fr; } }
</style>
</head>
<body>
<div class="app">
  <div class="panel">
    <h2>Site Map Dashboard</h2>
    <div class="controls">
      <div class="row">
        <label for="viewSelect">View</label>
        <select id="viewSelect"><option value="all">All Sites</option></select>
      </div>
      <div class="row">
        <div class="stat">
          <div class="small">Done</div>
          <div class="big-num"><span id="animDone">0</span> <span style="font-size:14px; color:#777; font-weight:400;">/ <span id="animTotal">0</span></span></div>
          <div class="small" id="donePct">0%</div>
        </div>
        <div class="stat">
          <div class="small">Pending</div>
          <div id="animPending" class="big-num">0</div>
          <div class="small" id="totalCountLabel">Total: 0</div>
        </div>
      </div>
      
      <div class="row legend small">
        <span id="swatchDone" class="sw"></span>Done
        <span id="swatchPending" class="sw"></span>Pending
        <span id="phase1Legend" style="display:none; margin-left:10px;">
          <span id="swatchPhase1" class="sw"></span>Phase 1
        </span>
      </div>
      
      <hr style="border:none;border-top:1px solid #eee;margin:12px 0;"/>
      <div class="row"><input id="searchInput" type="text" placeholder="Search eNodeB ID / Site name"/><button id="searchBtn" class="btn">Find</button></div>
      <div id="details">Hover a marker or search to see details here.</div>
    </div>
  </div>
  <div class="panel" style="padding:0;">
    <div id="map">
      
      <div id="gpsBtn" class="map-btn" title="Locate Me">
        <img src="https://cdn-icons-png.flaticon.com/512/1201/1201552.png" alt="GPS">
      </div>

      <div id="measureBtn" class="map-btn" title="Ruler Tool (Distance)">
        <img src="https://cdn-icons-png.flaticon.com/512/5594/5594876.png" alt="Ruler">
      </div>

      <div id="settingsBtn" class="map-btn" title="Map Settings">
        <img src="https://cdn-icons-png.flaticon.com/512/3524/3524659.png" alt="Settings">
      </div>
      
      <div id="sniperBtn" class="map-btn" title="Reset View">
        <img src="https://cdn-icons-png.flaticon.com/512/684/684908.png" alt="Reset">
      </div>

      <div id="settingsMenu">
        <div class="style-option" data-style="osm">Standard</div>
        <div class="style-option" data-style="satellite">Satellite</div>
        <div class="style-option" data-style="dark">Dark Mode</div>
        <div class="style-option" data-style="light">Light Mode</div>
        <div class="style-option" data-style="topo">Terrain</div>
      </div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// --- 1. MAP INITIALIZATION & STYLES ---
const map = L.map('map', { preferCanvas: true }).setView([3.0, 101.5], 11);

// Tile Layer Definitions (Updated Terrain)
const tileProviders = {
    osm: { url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', attr: '&copy; OpenStreetMap' },
    satellite: { url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', attr: '&copy; Esri' },
    dark: { url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', attr: '&copy; CartoDB' },
    light: { url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', attr: '&copy; CartoDB' },
    // CHANGED: Switched to Esri World Topo for reliable terrain/physical view
    topo: { url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', attr: '&copy; Esri' }
};

let currentTileLayer = null;

function setMapStyle(styleKey) {
    const provider = tileProviders[styleKey] || tileProviders.osm;
    if (currentTileLayer) map.removeLayer(currentTileLayer);
    currentTileLayer = L.tileLayer(provider.url, { 
        maxZoom: 19, 
        attribution: provider.attr 
    }).addTo(map);
    localStorage.setItem('siteMap_style', styleKey);
    document.querySelectorAll('.style-option').forEach(el => {
        el.classList.toggle('active', el.dataset.style === styleKey);
    });
}

// Load saved style or default to 'osm'
const savedStyle = localStorage.getItem('siteMap_style') || 'osm';
setMapStyle(savedStyle);

// --- 2. TOOL LOGIC (MEASURE & GPS) ---

// GPS Tool
document.getElementById('gpsBtn').addEventListener('click', () => {
    map.locate({setView: true, maxZoom: 15});
});
map.on('locationfound', (e) => {
    L.circleMarker(e.latlng, { radius: 8, color: '#2F80ED', fillColor: '#2F80ED', fillOpacity: 0.3 }).addTo(map).bindPopup("You are here").openPopup();
    L.circleMarker(e.latlng, { radius: 4, color: '#fff', fillColor: '#2F80ED', fillOpacity: 1 }).addTo(map);
});
map.on('locationerror', () => alert("Could not access location. Please enable GPS permissions."));

// Ruler Tool Logic
let isMeasuring = false;
let measurePoints = [];
let measureMarkers = [];
let measureLine = null;
let measureTooltip = null;

const measureBtn = document.getElementById('measureBtn');

measureBtn.addEventListener('click', toggleMeasureTool);

function toggleMeasureTool() {
    isMeasuring = !isMeasuring;
    const mapDiv = document.getElementById('map');
    
    if (isMeasuring) {
        measureBtn.classList.add('active');
        mapDiv.classList.add('crosshair-cursor');
        document.getElementById('details').innerHTML = "<strong>Ruler Active:</strong> Click on the map to start measuring distance.";
        map.on('click', onMeasureClick);
        map.on('mousemove', onMeasureMove);
    } else {
        clearMeasurement();
    }
}

function clearMeasurement() {
    isMeasuring = false;
    measureBtn.classList.remove('active');
    document.getElementById('map').classList.remove('crosshair-cursor');
    document.getElementById('details').innerHTML = "Hover a marker or search to see details here.";
    
    // Cleanup Layers
    measureMarkers.forEach(m => map.removeLayer(m));
    if (measureLine) map.removeLayer(measureLine);
    if (measureTooltip) map.removeLayer(measureTooltip);
    
    measurePoints = [];
    measureMarkers = [];
    measureLine = null;
    measureTooltip = null;
    
    map.off('click', onMeasureClick);
    map.off('mousemove', onMeasureMove);
}

function onMeasureClick(e) {
    const latlng = e.latlng;
    measurePoints.push(latlng);

    // Add Dot Marker
    const dot = L.circleMarker(latlng, {
        radius: 4, color: '#333', fillColor: '#fff', fillOpacity: 1, weight: 2
    }).addTo(map);
    measureMarkers.push(dot);

    if (measurePoints.length === 2) {
        // Finish Measurement
        finalizeMeasurement();
    }
}

function onMeasureMove(e) {
    if (measurePoints.length !== 1) return; // Only draw preview if we have exactly 1 start point
    
    const start = measurePoints[0];
    const current = e.latlng;
    
    // Draw/Update Preview Line
    if (measureLine) map.removeLayer(measureLine);
    measureLine = L.polyline([start, current], { color: 'black', dashArray: '5, 10', weight: 2 }).addTo(map);
    
    // Calculate Distance
    const distMeters = start.distanceTo(current);
    const distText = distMeters > 1000 ? (distMeters/1000).toFixed(2) + ' km' : Math.round(distMeters) + ' m';
    
    // Draw/Update Tooltip
    if (measureTooltip) map.removeLayer(measureTooltip);
    measureTooltip = L.tooltip({
        permanent: true, direction: 'right', className: 'measure-tooltip', offset: [10, 0]
    })
    .setLatLng(current)
    .setContent(distText)
    .addTo(map);
}

function finalizeMeasurement() {
    // Stop listening to moves
    map.off('mousemove', onMeasureMove);
    map.off('click', onMeasureClick);
    
    // Solidify line
    if (measureLine) {
        measureLine.setStyle({ dashArray: null, weight: 3, color: '#2F80ED' });
    }
    
    // Reset state but keep drawings until user clicks button again
    isMeasuring = false;
    measureBtn.classList.remove('active'); // Visually untoggle button
    document.getElementById('map').classList.remove('crosshair-cursor');
    
    // Allow clearing by clicking the button again (logic handled in toggleMeasureTool check)
    // We set a flag or just let toggleMeasureTool handle the reset on next click
    // For now, we manually re-add the 'active' class to button to indicate "Result Shown" if desired,
    // or just leave it off. Let's leave it off but keep data on map.
    // Next click on Ruler will trigger 'clearMeasurement' because logic starts fresh.
    isMeasuring = true; // Hack: keep it "true" so next click clears it
    measureBtn.classList.add('active'); 
    // But disable map clicks
    map.off('click', onMeasureClick); 
}


// --- 3. SETTINGS & REST OF APP ---
const settingsBtn = document.getElementById('settingsBtn');
const settingsMenu = document.getElementById('settingsMenu');

settingsBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    settingsMenu.classList.toggle('show');
});

document.addEventListener('click', (e) => {
    if (!settingsMenu.contains(e.target) && e.target !== settingsBtn) {
        settingsMenu.classList.remove('show');
    }
});

document.querySelectorAll('.style-option').forEach(option => {
    option.addEventListener('click', () => {
        setMapStyle(option.dataset.style);
        settingsMenu.classList.remove('show');
    });
});

let markersLayer = L.layerGroup().addTo(map);
const defaultColors = { done: '#66ff00', pending: '#1F4E79', phase1: '#A020F0' };
let statusColors = JSON.parse(localStorage.getItem('siteMap_colors')) || { ...defaultColors };

function updateLegendUI() {
    document.getElementById('swatchDone').style.background = statusColors.done;
    document.getElementById('swatchPending').style.background = statusColors.pending;
    document.getElementById('swatchPhase1').style.background = statusColors.phase1;
}
updateLegendUI();

let allRows = [], visibleMarkers = {}, pinnedMarker = null;
let uniqueBatches = new Set();
let batchMap = new Map();

function normalizeKey(k){ return (k||'').toString().trim().toLowerCase().replace(/\s+/g,'_'); }

function isDoneStatus(s){ 
  return /^(on\s*-?\s*air|onair|done|live|activated|active)$|(\bon\b)/i.test(s) && !/not\s+on/i.test(s); 
}

function runCounterAnimation(elementId, endValue) {
  const obj = document.getElementById(elementId);
  if (!obj) return;
  const startValue = parseInt(obj.textContent.replace(/,/g, '')) || 0;
  if (startValue === endValue) return;

  const duration = 1500;
  const startTime = performance.now();

  function update(currentTime) {
    const elapsed = currentTime - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const ease = (progress === 1) ? 1 : 1 - Math.pow(2, -10 * progress);
    const current = Math.floor(startValue + (endValue - startValue) * ease);
    obj.textContent = current.toLocaleString(); 
    if (progress < 1) requestAnimationFrame(update);
    else obj.textContent = endValue.toLocaleString(); 
  }
  requestAnimationFrame(update);
}

function levenshtein(a,b){
  a = a||''; b = b||'';
  const m = a.length, n = b.length;
  if(m===0) return n; if(n===0) return m;
  const dp = Array(n+1).fill(0).map((_,i)=>i);
  for(let i=1;i<=m;i++){
    let prev = dp[0]; dp[0] = i;
    for(let j=1;j<=n;j++){
      const temp = dp[j];
      const cost = a[i-1] === b[j-1] ? 0 : 1;
      dp[j] = Math.min(dp[j] + 1, dp[j-1] + 1, prev + cost);
      prev = temp;
    }
  }
  return dp[n];
}

function normForSearch(s){
  if(!s) return '';
  return s.toString().toLowerCase().normalize('NFKD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-z0-9]/g,'');
}

function fuzzyFindInRows(term, rows){
  term = term || '';
  const tNorm = normForSearch(term);
  if(!tNorm) return null;
  let exact = rows.find(r => (r.enodeb_id && r.enodeb_id.toString().trim() === term));
  if(exact) return { row: exact, score: 0, type: 'exact-id' };
  exact = rows.find(r => (r.site_name && normForSearch(r.site_name) === tNorm) || (r.enodeb_name && normForSearch(r.enodeb_name) === tNorm));
  if(exact) return { row: exact, score: 0, type: 'exact-name' };
  const substringMatches = rows.filter(r =>(r.enodeb_id && r.enodeb_id.toString().toLowerCase().includes(term.toLowerCase()))
    || (r.site_name && r.site_name.toString().toLowerCase().includes(term.toLowerCase()))
    || (r.enodeb_name && r.enodeb_name.toString().toLowerCase().includes(term.toLowerCase())));
  if(substringMatches.length === 1) return { row: substringMatches[0], score: 1, type: 'substring' };
  if(substringMatches.length > 1) {
    substringMatches.sort((a,b) => ( (a.site_name||a.enodeb_name||'').length - (b.site_name||b.enodeb_name||'').length ));
    return { row: substringMatches[0], score: 2, type: 'substring-multiple' };
  }
  let best = null;
  for(const r of rows){
    const candidates = [normForSearch(r.site_name || ''), normForSearch(r.enodeb_name || ''), normForSearch(r.enodeb_id || '')];
    for(const c of candidates){
      if(!c) continue;
      const dist = levenshtein(tNorm, c);
      const maxAllowed = Math.max(1, Math.floor(Math.min(3, c.length * 0.2)));
      if(dist <= maxAllowed){
        if(!best || dist < best.score) best = { row: r, score: dist, type: 'fuzzy' };
      }
    }
  }
  return best;
}

function updateFilterDropdown() {
  const select = document.getElementById('viewSelect');
  const storedValue = localStorage.getItem('siteMap_prefView');
  
  select.innerHTML = '<option value="all">All Sites</option>';
  Array.from(uniqueBatches).filter(batch => batch && batch.trim() !== '').sort().forEach(batch => {
      const option = document.createElement('option');
      option.value = batch.toLowerCase().replace(/\s+/g, '_');
      option.textContent = batch;
      select.appendChild(option);
      batchMap.set(option.value, batch);
  });

  if (storedValue) {
    const optionExists = Array.from(select.options).some(opt => opt.value === storedValue);
    if (optionExists) select.value = storedValue;
  }
}

function loadCsvText(text){
  const parsed = Papa.parse(text,{header:true, skipEmptyLines:true});
  if(!parsed || !parsed.data) return;
  allRows = []; uniqueBatches = new Set(); batchMap = new Map();
  parsed.data.forEach((r,i)=>{
    const norm = {}; for(const key in r) norm[normalizeKey(key)] = r[key];
    const enodeb_id = (norm['enodeb_id'] ?? norm['enodeb id'] ?? norm['enodeb'] ?? '') + '';
    const enodeb_name = (norm['enodeb_name'] ?? norm['enodeb name'] ?? '') + '';
    const site_name = (norm['site_name'] ?? norm['site name'] ?? '') + '';
    const swap_batch = (norm['swap_batch'] ?? norm['swap batch'] ?? '') + '';
    const status = (norm['status'] ?? '') + '';
    const lat = parseFloat((norm['latitude'] ?? norm['lat'] ?? '').toString().replace(/,/g,'.'));
    const lon = parseFloat((norm['longitude'] ?? norm['lon'] ?? norm['lng'] ?? '').toString().replace(/,/g,'.'));
    let on_air_date = norm['on_air_date'] || norm['on-air_date'] || norm['on_air'] || '';
    
    const row = {
      _rowIndex: i, enodeb_id, enodeb_name: enodeb_name || site_name, site_name,
      swap_batch, status, on_air_date, lat, lon,
      normalized_batch: (swap_batch || '').toLowerCase().replace(/\s+/g, '_')
    };
    allRows.push(row);
    if (swap_batch && swap_batch.trim() !== '') uniqueBatches.add(swap_batch.trim());
  });
  updateFilterDropdown();
  render();
}

function fetchFullList() {
  const SHEET_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSfL5XPVZGIaX_PNiDYtjftJOyep4x5IzOJNPvUMZQjt5TRdV-TZyRgzo5jM5vP-jxQljGtseIIQikm/pub?gid=232255476&single=true&output=csv';
  fetch(SHEET_CSV_URL)
    .then(r => r.text())
    .then(text => loadCsvText(text))
    .catch(err => alert('Could not fetch data from Google Sheets: ' + err));
}

// --- 4. RENDER LOGIC ---
function render(){
  const newMarkers = [];
  visibleMarkers = {};
  const view = document.getElementById('viewSelect').value;
  
  localStorage.setItem('siteMap_prefView', view);

  let rows = allRows.slice();
  if(view === 'all') {
    rows = allRows.filter(r => !['blocked', '24g_only', 'imacro'].includes(r.normalized_batch));
  } else if(view !== '') {
    rows = allRows.filter(r => r.normalized_batch === view);
  }

  let doneCount = 0, pendingCount = 0, countableTotal = 0;
  let hasPhase1 = false;
  const bounds = [];

  rows.forEach(r=>{
    if(!Number.isFinite(r.lat) || !Number.isFinite(r.lon)) return;
    
    const isPhase1 = (r.normalized_batch === 'phase_1' || r.normalized_batch === 'phase1');
    if (isPhase1) hasPhase1 = true;

    let color, displayStatus;
    
    if (isPhase1 && view === 'all') {
      color = statusColors.phase1; 
      displayStatus = "Done"; 
    } 
    else if (isPhase1 && view === 'phase_1') {
      color = statusColors.done;
      displayStatus = "Done";
      doneCount++; countableTotal++;
    } 
    else {
      const done = isDoneStatus(r.status);
      if(done) doneCount++; else pendingCount++;
      countableTotal++;
      color = done ? statusColors.done : statusColors.pending;
      displayStatus = r.status;
    }

    const popupHtml = `<div style="min-width:240px">
      <strong>${escapeHtml(r.enodeb_name)}</strong><br/>
      <em>Site Name:</em> ${escapeHtml(r.site_name)}<br/>
      <em>eNodeB ID:</em> ${escapeHtml(r.enodeb_id)}<br/>
      <em>Swap Batch:</em> ${escapeHtml(r.swap_batch)}<br/>
      <em>Status:</em> ${escapeHtml(displayStatus)}<br/>
      <em>On-Air Date:</em> ${escapeHtml(r.on_air_date || '—')}
    </div>`;

    const m = L.circleMarker([r.lat, r.lon], {
        radius: 6,
        fillColor: color,
        color: "#ffffff",
        weight: 2,
        opacity: 1,
        fillOpacity: 1
    });
    
    m.bindPopup(popupHtml, { autoClose:false, closeOnClick:false });
    m.on('mouseover', () => {
      // Don't show popups while measuring to avoid clutter
      if(isMeasuring) return;
      if(pinnedMarker && pinnedMarker !== m) pinnedMarker.closePopup();
      pinnedMarker = null;
      m.openPopup();
      document.getElementById('details').innerHTML = popupHtml;
    });
    m.on('mouseout', function() { if(pinnedMarker !== this) this.closePopup(); });
    m.on('click', function() {
      // Don't pin markers while measuring
      if(isMeasuring) return;
      if(pinnedMarker && pinnedMarker !== this) pinnedMarker.closePopup();
      pinnedMarker = this;
      this.openPopup();
      document.getElementById('details').innerHTML = popupHtml;
      map.setView(this.getLatLng(), 16);
    });

    newMarkers.push(m);
    const key = (r.enodeb_id || ('row' + r._rowIndex)).toString();
    visibleMarkers[key] = m;
    bounds.push([r.lat, r.lon]);
  });

  markersLayer.clearLayers();
  markersLayer = L.layerGroup(newMarkers).addTo(map);

  const p1Leg = document.getElementById('phase1Legend');
  if (p1Leg) p1Leg.style.display = (view === 'all' && hasPhase1) ? 'inline-block' : 'none';

  runCounterAnimation('animDone', doneCount);
  runCounterAnimation('animTotal', countableTotal);
  runCounterAnimation('animPending', pendingCount);
  
  document.getElementById('donePct').textContent = countableTotal ? (Math.round(doneCount/countableTotal*10000)/100) + '%' : '0%';
  document.getElementById('totalCountLabel').textContent = `Total: ${countableTotal}`;

  if(bounds.length){
    const b = L.latLngBounds(bounds);
    if(b.isValid()) map.fitBounds(b.pad(0.05));
  }
}

// --- 5. COLOR PICKER ---
function openColorPicker(initialColor, onInput, onChange) {
    const input = document.createElement('input');
    input.type = 'color';
    input.value = rgbToHex(initialColor);
    input.style.position = 'fixed'; 
    input.style.left = '-9999px'; 
    document.body.appendChild(input);

    input.click();

    input.addEventListener('input', (e) => {
        onInput(e.target.value);
    });

    input.addEventListener('change', (e) => {
        onChange(e.target.value);
        document.body.removeChild(input);
    });

    input.addEventListener('blur', () => {
        setTimeout(() => {
            if(document.body.contains(input)) document.body.removeChild(input);
        }, 500);
    });
}

function rgbToHex(rgb){
  if(!rgb) return '#000000';
  if(rgb.startsWith('#')) return rgb;
  const match = rgb.match(/\d+/g);
  if(!match) return '#000000';
  const nums = match.map(Number);
  return "#" + nums.map(n => n.toString(16).padStart(2,'0')).join('');
}

function initiateColorChange(key) {
    const swatchId = key === 'done' ? 'swatchDone' : key === 'pending' ? 'swatchPending' : 'swatchPhase1';
    const el = document.getElementById(swatchId);
    
    openColorPicker(
        statusColors[key], 
        (newColor) => {
            el.style.background = newColor;
            statusColors[key] = newColor; 
            updateMarkerColors(key, newColor);
        },
        (finalColor) => {
            el.style.background = finalColor;
            statusColors[key] = finalColor;
            localStorage.setItem('siteMap_colors', JSON.stringify(statusColors));
            updateMarkerColors(key, finalColor);
        }
    );
}

document.getElementById('swatchDone').addEventListener('click', () => initiateColorChange('done'));
document.getElementById('swatchPending').addEventListener('click', () => initiateColorChange('pending'));
document.getElementById('swatchPhase1').addEventListener('click', () => initiateColorChange('phase1'));

function updateMarkerColors(statusKey, color){
  for(const key in visibleMarkers){
    const m = visibleMarkers[key];
    const row = allRows.find(r => (r.enodeb_id || ('row'+r._rowIndex)).toString() === key);
    if(!row) continue;

    const isPhase1 = (row.normalized_batch === 'phase_1' || row.normalized_batch === 'phase1');
    const view = document.getElementById('viewSelect').value;

    let shouldUpdate = false;
    
    if (statusKey === 'phase1') {
        if (isPhase1 && view === 'all') shouldUpdate = true;
    } 
    else if (statusKey === 'done') {
        if (isPhase1 && view === 'all') { shouldUpdate = false; }
        else if (isDoneStatus(row.status)) { shouldUpdate = true; }
    }
    else if (statusKey === 'pending') {
        if (isPhase1 && view === 'all') { shouldUpdate = false; }
        else if (!isDoneStatus(row.status)) { shouldUpdate = true; }
    }
    
    if(shouldUpdate) m.setStyle({fillColor: color});
  }
}

function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

function searchAndZoom(term){
  if(!term || !term.toString().trim()){ alert('Enter a eNodeB ID, or Site name'); return; }
  term = term.toString().trim();
  if(visibleMarkers[term]){
    const m = visibleMarkers[term];
    map.setView(m.getLatLng(), 16);
    m.openPopup(); pinnedMarker = m;
    document.getElementById('details').innerHTML = m.getPopup().getContent();
    return;
  }
  const result = fuzzyFindInRows(term, allRows);
  if(result && result.row){
    const found = result.row;
    if(Number.isFinite(found.lat) && Number.isFinite(found.lon)){
      map.setView([found.lat, found.lon], 16);
      const key = (found.enodeb_id || ('row' + found._rowIndex)).toString();
      if(visibleMarkers[key]){
        const m = visibleMarkers[key];
        m.openPopup(); pinnedMarker = m;
        document.getElementById('details').innerHTML = m.getPopup().getContent();
      } else {
        document.getElementById('details').innerHTML = `<div style="min-width:220px"><strong>${escapeHtml(found.enodeb_name)}</strong><br/><em>Status:</em> ${escapeHtml(found.status)}</div>`;
      }
    }
  } else { alert('Site not found.'); }
}

document.getElementById('viewSelect').addEventListener('change', render);
document.getElementById('searchBtn').addEventListener('click', ()=> searchAndZoom(document.getElementById('searchInput').value));
document.getElementById('searchInput').addEventListener('keydown', e => { if(e.key==='Enter'){ e.preventDefault(); searchAndZoom(e.target.value); }});
document.getElementById('sniperBtn').addEventListener('click',()=>render());
  
window.addEventListener('load', ()=>{ fetchFullList(); setTimeout(()=>map.invalidateSize(),300); });

let lastCsvText = null;
const REFRESH_INTERVAL_MS = 30 * 1000; 

async function smartFetchCsv() {
  try {
    const BASE_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSfL5XPVZGIaX_PNiDYtjftJOyep4x5IzOJNPvUMZQjt5TRdV-TZyRgzo5jM5vP-jxQljGtseIIQikm/pub?gid=232255476&single=true&output=csv';
    const uniqueUrl = BASE_URL + '&_t=' + Date.now();

    const response = await fetch(uniqueUrl);
    if (!response.ok) throw new Error('Network response not ok');
    
    const csvText = await response.text();
    
    if (csvText !== lastCsvText) { 
      console.log("New data detected! Refreshing map...");
      lastCsvText = csvText; 
      loadCsvText(csvText); 
    } else {
      console.log("Data checked, but no changes found.");
    }
  } catch (err) { console.error('Error fetching CSV:', err); }
}

smartFetchCsv();
setInterval(smartFetchCsv, REFRESH_INTERVAL_MS);
</script>
</body>
</html>
